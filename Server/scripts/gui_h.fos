#ifndef __CLIENT_GUI__
#define __CLIENT_GUI__

#include "_defines.fos"
#include "_client_defines.fos"
#include "_colors.fos"
#include "_msgstr.fos"
#include "_math.fos"
#include "sprite.fos"
#include "serializator.fos"

#ifndef CLIENT_GUI
// Public API
import void       GUI_RegisterScreen( int screenIndex, GUIScreen& screen ) from "gui";
import GUIScreen@ GUI_GetScreen( int screenIndex ) from "gui";
import GUIScreen@ GUI_GetActiveMainScreen() from "gui";
import GUIScreen@ GUI_GetActiveScreen() from "gui";
import void       GUI_GetActiveScreens( GUIScreen@[]& result ) from "gui";
import GUIObject@ GUI_GetFocusedObject() from "gui";
import void       GUI_SetFocusedObject( GUIObject@ obj ) from "gui";
import GUIObject@ GUI_GetPressedObject() from "gui";
import GUIObject@ GUI_GetHoveredObject() from "gui";
import void       GUI_NextTextInput() from "gui";
import void       GUI_CollectMessageBoxes( GUIMessageBox@[]& messageBoxes ) from "gui";
import bool       GUI_IsConsoleActive() from "gui";
// import ItemCl@    GUI_GetDraggedItem() from "gui";
// import bool       GUI_IsDraggedItem( ItemCl@ item ) from "gui";

// GUI core callbacks
import void GUI_EngineCallback_Start() from "gui";
import void GUI_EngineCallback_ShowScreen( int screenIndex, dictionary@ params ) from "gui";
import void GUI_EngineCallback_HideScreen( int screenIndex ) from "gui";
import void GUI_EngineCallback_Render( bool mainScreen ) from "gui";
import void GUI_EngineCallback_MouseDown( int button ) from "gui";
import void GUI_EngineCallback_MouseUp( int button ) from "gui";
import void GUI_EngineCallback_MouseMove() from "gui";
import void GUI_EngineCallback_KeyDown( uint8 key, string@ text ) from "gui";
import void GUI_EngineCallback_KeyUp( uint8 key ) from "gui";
import void GUI_EngineCallback_InputLost() from "gui";
import void GUI_EngineCallback_Loop() from "gui";
import void GUI_EngineCallback_GetActiveScreens( int[]& result ) from "gui";
import void GUI_EngineCallback_ItemChanged( bool onMap ) from "gui";
import bool GUI_EngineCallback_CheckInterfaceHit( int x, int y ) from "gui";
import void GUI_Callback_OnResolutionChanged() from "gui";
import void GUI_Callback_OnLanguageChanged() from "gui";

// Inheritance
// GUIObject
//   GUIPanel
//     GUIScreen
//     GUIGrid
//       GUIItemView
//     GUIButton
//       GUICheckBox
//         GUIRadioButton
//   GUIText
//     GUITextInput
//       GUIConsole
//     GUIMessageBox

// Callbacks
// GUIObject
//   void OnConstruct()
//   void OnInit()
//   void OnShow()
//   void OnShow( dictionary@ params )
//   void OnHide()
//   void OnAppear()
//   void OnAppear( dictionary@ params )
//   void OnDisappear()
//   void OnDraw()
//   void OnMove( int deltaX, int deltaY )
//   void OnMouseDown( int button )
//   void OnMouseUp( int button, bool lost )
//   void OnMousePressed( int button )
//   void OnLMousePressed()
//   void OnRMousePressed()
//   void OnMouseClick( int button )
//   void OnLMouseClick()
//   void OnRMouseClick()
//   void OnMouseMove()
//   void OnGlobalMouseDown( int button )
//   void OnGlobalMouseUp( int button )
//   void OnGlobalMousePressed( int button )
//   void OnGlobalMouseClick( int button )
//   void OnGlobalMouseMove()
//   void OnInput()
//   void OnInput( uint8 key )
//   void OnInput( string& text )
//   void OnInput( uint8 key, string@ text )
//   void OnGlobalInput( uint8 key, string@ text )
//   void OnActiveChanged()
//   void OnFocusChanged()
//   void OnHoverChanged()
//   void OnResizeGrid( GUIObject@ cell, uint cellIndex )
//   void OnDrawItem( ItemCl@ item, GUIObject@ cell, uint cellIndex )
// GUICheckBox
//   void OnCheckedChanged()
// GUIItemView
//   bool OnCheckItem( ItemCl@ item )

// API
// GUIObject
//   bool Active
//   bool ActiveSelf
//   string Name
//   int PosX
//   int PosY
//   int AbsolutePosX
//   int AbsolutePosY
//   int Width
//   int Height
//   int Anchor
//   int Dock
//   bool IsNotHittable
//   bool CheckTransparentOnHit
//   bool IsFocused
//   bool IsPressed
//   bool IsHovered
//   uint ChildCount
//   GUIObject@ Parent
//   GUIScreen@ Screen
//   void Init( GUIObject@ parent )
//   void Remove()
//   void SetActive( bool active )
//   void SetPosition( int x, int y )
//   void SetPosition( string& iniKey )
//   void SetSize( int w, int h )
//   void SetAnchor( int anchorStyles )
//   void SetDock( int dockStyle )
//   void SetNotHittable( bool enabled )
//   void SetCheckTransparentOnHit( bool enabled )
//   GUIObject@ FindMouseHit( int x = __MouseX, int y = __MouseY )
//   bool IsMouseHit( int x = __MouseX, int y = __MouseY )
//   void Move( int deltaX, int deltaY )
//   void MouseClick( int button )
//   void Input( uint8 key, string& text )
//   GUIPanel@ FindPanel( string& name )
//   GUIText@ FindText( string& name )
//   GUITextInput@ FindTextInput( string& name )
//   GUIButton@ FindButton( string& name )
//   GUIObject@ Find( string& name )
//   GUIObject@ GetChild( uint index )
// GUIPanel : GUIObject
//   Sprite@ BackgroundImage
//   int BackgroundImageLayout
//   void SetBackgroundImage( string@ imageName, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetBackgroundImage( uint imageNameHash, int imageLayout = IMAGE_LAYOUT_NONE )
//   bool IsCanMove
//   bool IsMoveIgnoreBorders
//   void SetCanMove( bool enabled, bool ignoreBorders )
// GUIText : GUIObject
//   string@ Text (overridable)
//   int TextFont
//   uint TextColor
//   uint TextColorFocused
//   int TextFlags
//   void SetText( string@ text, int font, int flags )
//   void SetText( string@ text )
//   void SetTextFont( int font )
//   void SetTextFlags( int flags )
//   void SetTextColor( uint color )
//   void SetTextFocusedColor( uint color )
// GUITextInput : GUIText : GUIObject
//   uint InputLength
//   bool IsTextPassword
//   string PasswordChar
//   void SetInputLength( uint length )
//   void SetInputPassword( string@ passwordChar )
//   void SetCarriage( bool enable )
// GUIButton : GUIPanel : GUIObject
//   Sprite@ PressedImage
//   int PressedImageLayout
//   Sprite@ HoverImage
//   int HoverImageLayout
//   bool IsSwitched
//   bool IsDisabled
//   void SetPressedImage( string@ imageName, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetPressedImage( uint imageNameHash, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetHoverImage( string@ imageName, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetHoverImage( uint imageNameHash, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetDisabledImage( string@ imageName, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetDisabledImage( uint imageNameHash, int imageLayout = IMAGE_LAYOUT_NONE )
//   void SetSwitch( bool enabled )
//   void SetCondition( bool enabled )
// GUICheckBox : GUIButton : GUIPanel : GUIObject
//   bool IsChecked
//   void SetChecked( bool checked )
// GUIRadioButton : GUICheckBox : GUIButton : GUIPanel : GUIObject
// GUIScreen : GUIPanel : GUIObject
//   int Index
//   bool IsHardcoded
//   bool IsMain
//   bool IsModal
//   bool IsMultiinstance
//   bool IsCloseOnMiss
//   int Cursor
//   Todo: bool IsOnTop
//   void SetModal( bool enabled )
//   void SetMultiinstance( bool enabled )
//   void SetCloseOnMiss( bool enabled )
//   void SetCursor( int cursor )
// GUIGrid : GUIPanel : GUIObject
//   string@ CellPrototype
//   uint GridSize
//   int Columns
//   void ResizeGrid( uint size )
//   void SetCellPrototype( string name )
//   void SetGridSize( uint size )
//   void SetColumns( int length )
//   void SetPadding( int x, int y )
// GUIMessageBox : GUIText : GUIObject
//   string[] MessageTexts
//   int[] MessageTypes
//   string[] MessageTimes
//   int[] Filters
//   bool InvertMessages
//   void AddMessage( string@ text, int type )
//   void SetFilters( int[] filters )
//   void SetFilter( int messageType, bool enable )
//   void SetInvertMessages( bool invert )
// GUIConsole : GUITextInput : GUIText : GUIObject
//   string HistoryStorageName
//   string[]@ History
//   uint HistoryMaxLength
//   void SetHistoryStorage( string storageName )
//   void SetHistoryMaxLength( uint length )
#endif

shared class GUIObject
{
    bool       get_Active() final                { return _ActiveSelf && ( _Parent !is null ? _Parent.Active : true ); }
    bool       get_ActiveSelf() final            { return _ActiveSelf; }
    string@    get_Name() final                  { return _Name; }
    int        get_PosX() final                  { return _Parent !is null ? _AbsolutePosX - _Parent._AbsolutePosX : _AbsolutePosX; }
    int        get_PosY() final                  { return _Parent !is null ? _AbsolutePosY - _Parent._AbsolutePosY : _AbsolutePosY; }
    int        get_AbsolutePosX() final          { return _AbsolutePosX; }
    int        get_AbsolutePosY() final          { return _AbsolutePosY; }
    int        get_Width() final                 { return _Width; }
    int        get_Height() final                { return _Height; }
    int        get_Anchor() final                { return _Anchor; }
    int        get_Dock() final                  { return _Dock; }
    bool       get_IsNotHittable() final         { return _IsNotHittable; }
    bool       get_CheckTransparentOnHit() final { return _CheckTransparentOnHit; }
    bool       get_IsFocused() final             { return _IsFocused; }
    bool       get_IsPressed() final             { return _IsPressed; }
    bool       get_IsHovered() final             { return _IsHovered; }
    uint       get_ChildCount() final            { return _Children.length(); }
    GUIObject@ get_Parent() final                { return _Parent; }
    GUIScreen@ get_Screen() final                { return _Parent !is null ? _Parent.Screen : cast< GUIScreen >( this ); }

    bool       _ActiveSelf;
    string@    _Name;
    int        _BasePosX;
    int        _BasePosY;
    int        _BaseWidth;
    int        _BaseHeight;
    int        _AbsolutePosX;
    int        _AbsolutePosY;
    int        _Width;
    int        _Height;
    int        _Anchor;
    int        _Dock;
    bool       _IsNotHittable;
    bool       _CheckTransparentOnHit;
    bool       _IsFocused;
    bool       _IsPressed;
    bool       _IsHovered;
    int        _PressedButton;
    int        _PressedX;
    int        _PressedY;
    uint       _PressedRepeatTime;
    GUIObject@ _Parent;
    GUIObject@[] _Children;

    // Callbacks
    void OnConstruct()                                               {}
    void OnInit()                                                    {}
    void OnShow()                                                    {}
    void OnShow( dictionary@ params )                                {}
    void OnHide()                                                    {}
    void OnAppear()                                                  {}
    void OnAppear( dictionary@ params )                              {}
    void OnDisappear()                                               {}
    void OnRemove()                                                  {}
    void OnDraw()                                                    {}
    void OnMove( int deltaX, int deltaY )                            {}
    void OnMouseDown( int button )                                   {}
    void OnMouseUp( int button, bool lost )                          {}
    void OnMousePressed( int button )                                {}
    void OnLMousePressed()                                           {}
    void OnRMousePressed()                                           {}
    void OnMouseClick( int button )                                  {}
    void OnLMouseClick()                                             {}
    void OnRMouseClick()                                             {}
    void OnMouseMove()                                               {}
    void OnGlobalMouseDown( int button )                             {}
    void OnGlobalMouseUp( int button )                               {}
    void OnGlobalMousePressed( int button )                          {}
    void OnGlobalMouseClick( int button )                            {}
    void OnGlobalMouseMove()                                         {}
    void OnInput()                                                   {}
    void OnInput( uint8 key )                                        {}
    void OnInput( string& text )                                     {}
    void OnInput( uint8 key, string@ text )                          {}
    void OnGlobalInput( uint8 key, string@ text )                    {}
    void OnActiveChanged()                                           {}
    void OnFocusChanged()                                            {}
    void OnHoverChanged()                                            {}
    void OnResizeGrid( GUIObject@ cell, uint cellIndex )             {}
    void OnDrawItem( ItemCl@ item, GUIObject@ cell, uint cellIndex ) {}

    void Init( GUIObject@ parent )
    {
        _ActiveSelf = true;
        @_Name = reflection::typeof < GUIObject > ( this ).nameWithoutNamespace;

        if( _Parent !is null )
            _Parent._Children.removeAt( _Parent._Children.findByRef( this ) );
        @_Parent = parent;
        if( parent !is null )
            parent._Children.insertLast( this );

        OnConstruct();

        GUIScreen@ screen = Screen;
        if( screen !is null && screen._IsRegistered )
            _Init();

        _RefreshPosition();
    }

    void _Init()
    {
        OnInit();
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._Init();
    }

    void _Show( dictionary@ params )
    {
        OnShow();
        OnShow( params );
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._Show( params );
    }

    void _Hide()
    {
        OnHide();
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._Hide();
    }

    void _Appear( dictionary@ params )
    {
        OnAppear();
        OnAppear( params );
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._Appear( params );
    }

    void _Disappear()
    {
        OnDisappear();
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._Disappear();
    }

    void Remove()
    {
        if( _Parent !is null )
        {
            _Parent._Children.removeAt( _Parent._Children.findByRef( this ) );
            @_Parent = null;
        }

        _Remove();

        _ActiveSelf = false;
    }

    void _Remove()
    {
        OnRemove();
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._Remove();
    }

    void _Reload( bool reconstruct, bool refreshPosition )
    {
        if( reconstruct )
            OnConstruct();
        if( refreshPosition )
            _RefreshPosition();

        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._Reload( reconstruct, refreshPosition );
    }

    void _Draw()
    {
        // Callback
        OnDraw();

        // _Children
        for( uint i = 0; i < _Children.length(); i++ )
            if( _Children[ i ]._ActiveSelf )
                _Children[ i ]._Draw();
    }

    void Move( int deltaX, int deltaY )
    {
        _Move( deltaX, deltaY, true, true );
    }

    void _Move( int deltaX, int deltaY, bool callCallback, bool moveBasePos )
    {
        _AbsolutePosX += deltaX;
        _AbsolutePosY += deltaY;

        if( moveBasePos )
        {
            _BasePosX += deltaX;
            _BasePosY += deltaY;
        }

        if( callCallback )
            OnMove( deltaX, deltaY );

        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._Move( deltaX, deltaY, callCallback, false );
    }

    GUIObject@ FindMouseHit( int x = __MouseX, int y = __MouseY )
    {
        // Check children
        for( int i = int( _Children.length() ) - 1; i >= 0; i-- )
        {
            GUIObject@ obj = _Children[ i ].FindMouseHit( x, y );
            if( obj !is null )
                return obj;
        }

        // Check own
        if( IsMouseHit( x, y ) )
            return this;

        // No collision found
        return null;
    }

    bool IsMouseHit( int x = __MouseX, int y = __MouseY )
    {
        return Active && !_IsNotHittable && _Width > 0 && _Height > 0 && IS_COLLISION( x, y, _AbsolutePosX, _AbsolutePosY, _Width, _Height );
    }

    void _MouseDown( int button )
    {
        _IsPressed = true;
        _PressedButton = button;
        _PressedX = __MouseX;
        _PressedY = __MouseY;
        OnMouseDown( button );

        Screen._GlobalMousePressed( button );
        _MousePressed( button );
        _PressedRepeatTime = GetTick() + 500;
    }

    void _MousePressed( int button )
    {
        OnMousePressed( button );
        if( button == MOUSE_BUTTON_LEFT )
            OnLMousePressed();
        else if( button == MOUSE_BUTTON_RIGHT )
            OnRMousePressed();
        _PressedRepeatTime = GetTick() + 40;
    }

    void _MouseUp( bool lost )
    {
        _IsPressed = false;
        OnMouseUp( _PressedButton, lost );
    }

    void MouseClick( int button )
    {
        OnMouseClick( button );
        if( button == MOUSE_BUTTON_LEFT )
            OnLMouseClick();
        else if( button == MOUSE_BUTTON_RIGHT )
            OnRMouseClick();
    }

    void _MouseMove()
    {
        OnMouseMove();
    }

    void _GlobalMouseDown( int button )
    {
        OnGlobalMouseDown( button );
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._GlobalMouseDown( button );
    }

    void _GlobalMouseUp( int button )
    {
        OnGlobalMouseUp( button );
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._GlobalMouseUp( button );
    }

    void _GlobalMousePressed( int button )
    {
        OnGlobalMousePressed( button );
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._GlobalMousePressed( button );
    }

    void _GlobalMouseClick( int button )
    {
        OnGlobalMouseClick( button );
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._GlobalMouseClick( button );
    }

    void _GlobalMouseMove()
    {
        OnGlobalMouseMove();
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._GlobalMouseMove();
    }

    void Input( uint8 key, string@ text )
    {
        OnInput();
        if( text is null )
            OnInput( key );
        else
            OnInput( text );
        OnInput( key, text );
    }

    void _GlobalInput( uint8 key, string@ text )
    {
        OnGlobalInput( key, text );
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._GlobalInput( key, text );
    }

    void _Focus()
    {
        if( !_IsFocused )
        {
            _IsFocused = true;
            OnFocusChanged();
        }
    }

    void _Unfocus()
    {
        if( _IsFocused )
        {
            _IsFocused = false;
            OnFocusChanged();
        }
    }

    void _Hover()
    {
        if( !_IsHovered )
        {
            _IsHovered = true;
            OnHoverChanged();
        }
    }

    void _Unhover()
    {
        if( _IsHovered )
        {
            _IsHovered = false;
            OnHoverChanged();
        }
    }

    GUIObject@ _Clone( GUIObject@ parent = null )
    {
        GUIObject@ newObject = _CloneExt( parent );
        newObject._Init();
        return @newObject;
    }

    GUIObject@ _CloneExt( GUIObject@ parent )
    {
        GUIObject@           newObject;
        reflection::typeof < GUIObject > ( this ).instantiate( @this, @newObject );
        newObject._Children.resize( 0 );
        @newObject._Parent = parent;
        if( parent !is null )
            parent._Children.insertLast( newObject );
        newObject.OnConstruct();
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._CloneExt( newObject );
        return @newObject;
    }

    GUIPanel@ FindPanel( string& name )
    {
        return cast< GUIPanel >( Find( name ) );
    }

    GUIText@ FindText( string& name )
    {
        return cast< GUIText >( Find( name ) );
    }

    GUITextInput@ FindTextInput( string& name )
    {
        return cast< GUITextInput >( Find( name ) );
    }

    GUIButton@ FindButton( string& name )
    {
        return cast< GUIButton >( Find( name ) );
    }

    GUIObject@ Find( string& name )
    {
        if( _Name !is null && _Name == name )
            return this;
        for( uint i = 0; i < _Children.length(); i++ )
        {
            GUIObject@ obj = _Children[ i ].Find( name );
            if( obj !is null )
                return obj;
        }
        return null;
    }

    GUIObject@ GetChild( uint index )
    {
        return _Children[ index ];
    }

    void _RefreshPosition()
    {
        // Base data
        _Width = _BaseWidth;
        _Height = _BaseHeight;
        int parentAbsolutePosX = ( _Parent !is null ? _Parent._AbsolutePosX : 0 );
        int parentAbsolutePosY = ( _Parent !is null ? _Parent._AbsolutePosY : 0 );
        int parentWidth = ( _Parent !is null ? _Parent._Width : __ScreenWidth );
        int parentHeight = ( _Parent !is null ? _Parent._Height : __ScreenHeight );
        int parentBaseWidth = ( _Parent !is null ? _Parent._BaseWidth : _BaseWidth );
        int parentBaseHeight = ( _Parent !is null ? _Parent._BaseHeight : _BaseHeight );

        // Dock
        int newPosX;
        int newPosY;
        if( _Dock != 0 )
        {
            if( _Dock == DOCK_LEFT )
            {
                newPosX = parentAbsolutePosX;
                newPosY = parentAbsolutePosY;
                _Height = parentHeight;
            }
            else if( _Dock == DOCK_RIGHT )
            {
                newPosX = parentAbsolutePosX + parentWidth - _Width;
                newPosY = parentAbsolutePosY;
                _Height = parentHeight;
            }
            else if( _Dock == DOCK_TOP )
            {
                newPosX = parentAbsolutePosX;
                newPosY = parentAbsolutePosY;
                _Width = parentWidth;
            }
            else if( _Dock == DOCK_BOTTOM )
            {
                newPosX = parentAbsolutePosX;
                newPosY = parentAbsolutePosY + parentHeight - _Height;
                _Width = parentWidth;
            }
            else if( _Dock == DOCK_FILL )
            {
                newPosX = parentAbsolutePosX;
                newPosY = parentAbsolutePosY;
                _Width = parentWidth;
                _Height = parentHeight;
            }
            else
            {
                newPosX = _BasePosX + parentAbsolutePosX;
                newPosY = _BasePosY + parentAbsolutePosY;
            }
        }
        // Anchor
        else
        {
            if( ( _Anchor & ANCHOR_LEFT ) != 0 )
                newPosX = parentAbsolutePosX + _BasePosX;
            else if( ( _Anchor & ANCHOR_RIGHT ) != 0 )
                newPosX = parentAbsolutePosX + _BasePosX + ( parentWidth - parentBaseWidth );
            else
                newPosX = parentAbsolutePosX + _BasePosX + ( parentWidth - parentBaseWidth ) / 2;

            if( ( _Anchor & ANCHOR_TOP ) != 0 )
                newPosY = parentAbsolutePosY + _BasePosY;
            else if( ( _Anchor & ANCHOR_BOTTOM ) != 0 )
                newPosY = parentAbsolutePosY + _BasePosY + ( parentHeight - parentBaseHeight );
            else
                newPosY = parentAbsolutePosY + _BasePosY + ( parentHeight - parentBaseHeight ) / 2;
        }

        // Move control
        if( newPosX != _AbsolutePosX || newPosY != _AbsolutePosY )
            _Move( newPosX - _AbsolutePosX, newPosY - _AbsolutePosY, false, false );
    }

    void _SizeChanged()
    {
        // Internal callback
    }

    // Options
    void SetName( string@ name )
    {
        @_Name = name;
    }

    void SetActive( bool active )
    {
        if( _ActiveSelf != active )
        {
            _ActiveSelf = active;
            _ActiveChanged();
        }
    }

    void _ActiveChanged()
    {
        OnActiveChanged();
        for( uint i = 0; i < _Children.length(); i++ )
            _Children[ i ]._ActiveChanged();
    }

    void SetPosition( int x, int y )
    {
        _BasePosX = x;
        _BasePosY = y;
        _RefreshPosition();
    }

    void SetPosition( string& iniKey )
    {
        // Parse four values from ini option
        string@ str = GetIfaceIniStr( iniKey );
        if( @str == null || str == "" )
            return;

        string@[] @ valuesStr = splitEx( str, " " );
        if( valuesStr.length() != 4 )
            return;

        int[] values( 4 );
        for( int i = 0; i < 4; i++ )
            values[ i ] = valuesStr[ i ].toInt();

        _BasePosX = values[ 0 ];
        _BasePosY = values[ 1 ];
        _BaseWidth = values[ 2 ] - values[ 0 ];
        _BaseHeight = values[ 3 ] - values[ 1 ];
        _RefreshPosition();
    }

    void SetSize( int w, int h )
    {
        _BaseWidth = w;
        _BaseHeight = h;
        _RefreshPosition();
        _SizeChanged();
    }

    void SetAnchor( int anchorStyles )
    {
        _Anchor = anchorStyles;
        _RefreshPosition();
    }

    void SetDock( int dockStyle )
    {
        _Dock = dockStyle;
        _RefreshPosition();
    }

    void SetNotHittable( bool enabled )
    {
        _IsNotHittable = enabled;
    }

    void SetCheckTransparentOnHit( bool enabled )
    {
        _CheckTransparentOnHit = enabled;
    }
}

shared class GUIPanel : GUIObject
{
    Sprite@ get_BackgroundImage() final       { return _BackgroundImage; }
    int     get_BackgroundImageLayout() final { return _BackgroundImage !is null ? _BackgroundImage.Layout : IMAGE_LAYOUT_NONE; }
    bool    get_IsCanMove() final             { return _IsCanMove; }
    bool    get_IsMoveIgnoreBorders() final   { return _IsMoveIgnoreBorders; }

    Sprite@ _BackgroundImage;
    bool    _IsCanMove;
    bool    _IsMoveIgnoreBorders;

    bool IsMouseHit( int x = __MouseX, int y = __MouseY ) override
    {
        if( GUIObject::IsMouseHit( x, y ) )
        {
            if( _CheckTransparentOnHit && _BackgroundImage !is null )
                return ( GetPixelColor( _BackgroundImage.Id, _BackgroundImage.Frame, x - _AbsolutePosX, y - _AbsolutePosY ) & 0xFF000000 ) != 0;
            return true;
        }
        return false;
    }

    void _Draw() override
    {
        // Normal sprite
        if( _BackgroundImage !is null )
            _DrawImage( _BackgroundImage );

        GUIObject::_Draw();
    }

    void _DrawImage( Sprite@ image )
    {
        image.Draw( _AbsolutePosX, _AbsolutePosY, _Width, _Height );
    }

    void _GlobalMouseMove() override
    {
        // Process moving
        if( _IsCanMove ) // Todo: IsOnTop
        {
            GUIObject@ pressedObj = _FindPressed( this );
            if( pressedObj !is null && pressedObj._PressedButton == MOUSE_BUTTON_LEFT && cast< GUIPanel >( pressedObj ) !is null )
            {
                int lastPosX = _AbsolutePosX;
                int lastPosY = _AbsolutePosY;
                int newPosX = _AbsolutePosX + ( __MouseX - pressedObj._PressedX );
                int newPosY = _AbsolutePosY + ( __MouseY - pressedObj._PressedY );
                pressedObj._PressedX = __MouseX;
                pressedObj._PressedY = __MouseY;

                // Check screen borders
                if( !_IsMoveIgnoreBorders )
                {
                    int parentAbsolutePosX = ( _Parent !is null ? _Parent._AbsolutePosX : 0 );
                    int parentAbsolutePosY = ( _Parent !is null ? _Parent._AbsolutePosY : 0 );
                    int parentWidth = ( _Parent !is null ? _Parent._Width : __ScreenWidth );
                    int parentHeight = ( _Parent !is null ? _Parent._Height : __ScreenHeight );
                    int px = newPosX;
                    int py = newPosY;
                    if( newPosX < parentAbsolutePosX )
                        newPosX = parentAbsolutePosX;
                    if( newPosY < parentAbsolutePosY )
                        newPosY = parentAbsolutePosY;
                    if( newPosX + _Width > parentWidth )
                        newPosX = parentWidth - _Width;
                    if( newPosY + _Height > parentHeight )
                        newPosY = parentHeight - _Height;
                    pressedObj._PressedX += newPosX - px;
                    pressedObj._PressedY += newPosY - py;
                }

                // Callback
                if( lastPosX != newPosX || lastPosY != newPosY )
                {
                    int deltaX = newPosX - lastPosX;
                    int deltaY = newPosY - lastPosY;
                    _Move( deltaX, deltaY, true, true );
                }
            }
        }

        GUIObject::_GlobalMouseMove();
    }

    GUIObject@ _FindPressed( GUIObject@ obj )
    {
        if( obj._IsPressed )
            return obj;
        for( uint i = 0; i < obj._Children.length(); i++ )
        {
            GUIObject@ pressedObj = _FindPressed( obj._Children[ i ] );
            if( pressedObj !is null )
                return pressedObj;
        }
        return null;
    }

    void SetBackgroundImage( string@ imageName, int imageLayout = IMAGE_LAYOUT_NONE )
    {
        _SetImage( _BackgroundImage, imageName, imageLayout );
    }

    void SetBackgroundImage( uint imageNameHash, int imageLayout = IMAGE_LAYOUT_NONE )
    {
        _SetImage( _BackgroundImage, imageNameHash, imageLayout );
    }

    void _SetImage( Sprite@& curImage, string@ imageName, int imageLayout )
    {
        @curImage = null;
        if( imageName !is null )
        {
            Sprite spr;
            spr.Load( imageName, ( findFirst( imageName, "/" ) != -1 || findFirst( imageName, "\\" ) != -1 ) ? PT_DATA : PT_ART_INTRFACE );
            if( spr.Id != 0 )
                @curImage = spr;
        }

        if( curImage !is null )
            curImage.Layout = imageLayout;

        if( curImage !is null && ( imageLayout == IMAGE_LAYOUT_NONE || ( _BaseWidth == 0 && _BaseHeight == 0 ) ) )
            SetSize( curImage.Width, curImage.Height );
    }

    void _SetImage( Sprite@& curImage, uint imageNameHash, int imageLayout )
    {
        @curImage = null;
        if( imageNameHash != 0 )
        {
            Sprite spr;
            spr.Load( imageNameHash );
            if( spr.Id != 0 )
                @curImage = spr;
        }

        if( curImage !is null )
            curImage.Layout = imageLayout;

        if( curImage !is null && ( imageLayout == IMAGE_LAYOUT_NONE || ( _BaseWidth == 0 && _BaseHeight == 0 ) ) )
            SetSize( curImage.Width, curImage.Height );
    }

    void SetCanMove( bool enabled, bool ignoreBorders )
    {
        _IsCanMove = enabled;
        _IsMoveIgnoreBorders = ignoreBorders;
    }
}

shared class GUIText : GUIObject
{
    string@ get_Text()                   { return _Text; }
    int     get_TextFont() final         { return _TextFont; }
    uint    get_TextColor() final        { return _TextColor; }
    uint    get_TextColorFocused() final { return _TextColorFocused; }
    int     get_TextFlags() final        { return _TextFlags; }

    string _Text;
    int    _TextFont = FONT_DEFAULT;
    uint   _TextColor = COLOR_TEXT;
    uint   _TextColorFocused;
    int    _TextFlags;

    void _Draw() override
    {
        // Text
        string@ text = Text;
        if( text.length() > 0 )
        {
            uint color = ( _IsFocused && _TextColorFocused != 0 ? _TextColorFocused : _TextColor );
            DrawText( text, _AbsolutePosX, _AbsolutePosY, _Width, _Height, color, _TextFont, _TextFlags );
        }

        GUIObject::_Draw();
    }

    void SetText( string@ text, int font, int flags )
    {
        if( text !is null )
            _Text = text;
        else
            _Text = "";

        _TextFont = font;
        _TextFlags = flags;
    }

    void SetText( string@ text )
    {
        if( text !is null )
            _Text = text;
        else
            _Text = "";
    }

    void SetTextFont( int font )
    {
        _TextFont = font;
    }

    void SetTextFlags( int flags )
    {
        _TextFlags = flags;
    }

    void SetTextColor( uint color )
    {
        _TextColor = color;
    }

    void SetTextFocusedColor( uint color )
    {
        _TextColorFocused = color;
    }
}

#define PASSWORD_SHOW_TIME    ( 1000 )
shared class GUITextInput : GUIText
{
    uint   get_InputLength() final    { return _InputLength; }
    bool   get_IsTextPassword() final { return _IsTextPassword; }
    string get_PasswordChar() final   { return _PasswordChar; }

    uint   _InputLength;
    bool   _IsTextPassword;
    string _PasswordChar;
    uint   _PasswordTime;
    int    _CarriagePos;

    void Init( GUIObject@ parent ) override
    {
        GUIText::Init( parent );

        SetCarriage( false );
        _TextColorFocused = COLOR_TEXT_FOCUSED;
    }

    void _Draw() override
    {
        // Text
        string@ text = Text;
        if( _IsTextPassword )
        {
            string@ rawText = text;
            @text = "";
            for( uint i = 0; i < rawText.length(); i++ )
                text += _PasswordChar;
            if( GetTick() - _PasswordTime <= PASSWORD_SHOW_TIME )
                text[ -1 ] = rawText[ -1 ];
        }
        if( _CarriagePos != -1 && _IsFocused )
        {
            if( _CarriagePos < 0 )
                _CarriagePos = 0;
            if( _CarriagePos > int( text.length() ) )
                _CarriagePos = text.length();
            @text = text.substring( 0, _CarriagePos ) + ( GetTick() % 800 < 400 ? "!" : "." ) + text.substring( _CarriagePos );
        }
        if( text.length() > 0 )
        {
            uint color = ( _IsFocused && _TextColorFocused != 0 ? _TextColorFocused : _TextColor );
            DrawText( text, _AbsolutePosX, _AbsolutePosY, _Width, _Height, color, _TextFont, _TextFlags );
        }

        GUIObject::_Draw();
    }

    void Input( uint8 key, string@ text ) override
    {
        uint oldLen = _Text.length();
        _ProcessKey( key, text, _Text, _CarriagePos );
        while( _InputLength != 0 && _Text.length() > _InputLength )
            _Text[ -1 ] = "";
        if( _IsTextPassword )
            _PasswordTime = ( _Text.length() > oldLen ? GetTick() : 0 );

        GUIText::Input( key, text );
    }

    bool _ProcessKey( uint8 key, string@ text, string& resultText, int& carriagePos )
    {
        if( carriagePos != -1 )
        {
            if( carriagePos < 0 )
                carriagePos = 0;
            else if( carriagePos > int( resultText.length() ) )
                carriagePos = resultText.length();

            if( key == DIK_BACK )
            {
                if( carriagePos > 0 )
                {
                    resultText[ carriagePos - 1 ] = "";
                    carriagePos--;
                }
            }
            else if( key == DIK_DELETE )
            {
                if( carriagePos < int( resultText.length() ) )
                    resultText[ carriagePos ] = "";
            }
            else if( key == DIK_RIGHT )
            {
                if( carriagePos < int( resultText.length() ) )
                    carriagePos++;
            }
            else if( key == DIK_LEFT )
            {
                if( carriagePos > 0 )
                    carriagePos--;
            }
            else if( key == DIK_HOME )
            {
                carriagePos = 0;
            }
            else if( key == DIK_END )
            {
                carriagePos = resultText.length();
            }
            else if( text !is null )
            {
                resultText = resultText.substring( 0, carriagePos ) + text + resultText.substring( carriagePos );
                carriagePos += text.length();
            }
            else
            {
                return false;
            }
        }
        else
        {
            if( key == DIK_BACK )
            {
                if( resultText.length() > 0 )
                    resultText[ -1 ] = "";
            }
            else if( text !is null )
            {
                resultText += text;
            }
            else
            {
                return false;
            }
        }
        return true;
    }

    void SetInputLength( uint length )
    {
        _InputLength = length;
    }

    void SetInputPassword( string@ passwordChar )
    {
        _IsTextPassword = ( @passwordChar != null && passwordChar.length() == 1 );
        _PasswordChar = passwordChar;
        _PasswordTime = 0;
    }

    void SetCarriage( bool enable )
    {
        _CarriagePos = ( enable ? int( _Text.length() ) : -1 );
    }
}

shared class GUIButton : GUIPanel
{
    bool    get_IsDisabled() final          { return _IsDisabled; }
    bool    get_IsSwitched() final          { return _IsSwitched; }
    Sprite@ get_PressedImage() final        { return _PressedImage; }
    int     get_PressedImageLayout() final  { return _PressedImage !is null ? _PressedImage.Layout : IMAGE_LAYOUT_NONE; }
    Sprite@ get_HoverImage() final          { return _HoverImage; }
    int     get_HoverImageLayout() final    { return _HoverImage !is null ? _HoverImage.Layout : IMAGE_LAYOUT_NONE; }
    Sprite@ get_DisabledImage() final       { return _DisabledImage; }
    int     get_DisabledImageLayout() final { return _DisabledImage !is null ? _DisabledImage.Layout : IMAGE_LAYOUT_NONE; }

    bool    _IsDisabled;
    bool    _IsSwitched;
    Sprite@ _PressedImage;
    Sprite@ _HoverImage;
    Sprite@ _DisabledImage;

    void _Draw() override
    {
        if( !_IsDisabled )
        {
            // Pressed image
            bool isPressed = ( ( _IsPressed && _PressedButton == MOUSE_BUTTON_LEFT ) || _IsSwitched );
            if( isPressed && _PressedImage !is null )
                _DrawImage( _PressedImage );
            // Hover image
            else if( _IsHovered && _HoverImage !is null )
                _DrawImage( _HoverImage );
            // Normal image
            else if( _BackgroundImage !is null )
                _DrawImage( _BackgroundImage );
        }
        else
        {
            // Disabled image
            if( _DisabledImage !is null )
                _DrawImage( _PressedImage );
            // Normal image
            else if( _BackgroundImage !is null )
                _DrawImage( _BackgroundImage );
        }

        GUIObject::_Draw();
    }

    void MouseClick( int button )
    {
        if( _IsDisabled )
            return;

        GUIPanel::MouseClick( button );
    }

    void _MousePressed( int button )
    {
        if( _IsDisabled )
            return;

        GUIPanel::_MousePressed( button );
    }

    void SetPressedImage( string@ imageName, int imageLayout = IMAGE_LAYOUT_NONE )
    {
        _SetImage( _PressedImage, imageName, imageLayout );
    }

    void SetPressedImage( uint imageNameHash, int imageLayout = IMAGE_LAYOUT_NONE )
    {
        _SetImage( _PressedImage, imageNameHash, imageLayout );
    }

    void SetHoverImage( string@ imageName, int imageLayout = IMAGE_LAYOUT_NONE )
    {
        _SetImage( _HoverImage, imageName, imageLayout );
    }

    void SetHoverImage( uint imageNameHash, int imageLayout = IMAGE_LAYOUT_NONE )
    {
        _SetImage( _HoverImage, imageNameHash, imageLayout );
    }

    void SetDisabledImage( string@ imageName, int imageLayout = IMAGE_LAYOUT_NONE )
    {
        _SetImage( _DisabledImage, imageName, imageLayout );
    }

    void SetDisabledImage( uint imageNameHash, int imageLayout = IMAGE_LAYOUT_NONE )
    {
        _SetImage( _DisabledImage, imageNameHash, imageLayout );
    }

    void SetSwitch( bool enabled )
    {
        _IsSwitched = enabled;
    }

    void SetCondition( bool enabled )
    {
        _IsDisabled = !enabled;
    }
}

shared class GUICheckBox : GUIButton
{
    bool get_IsChecked() final { return _IsSwitched; }

    // Callbacks
    void OnCheckedChanged() {}

    void MouseClick( int button )
    {
        if( _IsDisabled )
            return;

        if( button == MOUSE_BUTTON_LEFT )
            SetChecked( !_IsSwitched );

        GUIPanel::MouseClick( button );
    }

    void SetChecked( bool checked )
    {
        if( _IsSwitched != checked )
        {
            _IsSwitched = checked;
            OnCheckedChanged();
        }
    }
}

shared class GUIRadioButton : GUICheckBox
{
    void MouseClick( int button )
    {
        if( _IsDisabled || _IsSwitched )
            return;

        if( button == MOUSE_BUTTON_LEFT )
            SetChecked( true );

        GUIPanel::MouseClick( button );
    }

    void SetChecked( bool checked ) override
    {
        if( checked && _Parent !is null )
        {
            for( uint i = 0; i < _Parent._Children.length(); i++ )
            {
                GUIRadioButton@ button = cast< GUIRadioButton >( _Parent._Children[ i ] );
                if( button !is null && button._IsSwitched )
                {
                    button._IsSwitched = false;
                    button.OnCheckedChanged();
                }
            }
        }

        if( _IsSwitched != checked )
        {
            _IsSwitched = checked;
            OnCheckedChanged();
        }
    }
}

shared class GUIScreen : GUIPanel
{
    int  get_Index() final           { return _Index; }
    bool get_IsHardcoded() final     { return _IsHardcoded; }
    bool get_IsMain() final          { return IS_CLIENT_MAIN_SCREEN( _Index ); }
    bool get_IsModal() final         { return _IsModal; }
    bool get_IsMultiinstance() final { return _IsMultiinstance; }
    bool get_IsCloseOnMiss() final   { return _IsCloseOnMiss; }
    int  get_Cursor() final          { return _Cursor; }

    int  _Index;
    bool _IsHardcoded;
    bool _IsRegistered;
    bool _IsModal;
    bool _IsMultiinstance;
    bool _IsCloseOnMiss;
    int  _Cursor = CURSOR_DEFAULT;

    // Workaround for input state accessing from shared code
    bool[] @ _InputKeyPressed;
    bool[] @ _InputMousePressed;

    void _Show( dictionary@ params ) override
    {
        // Make screen active
        _ActiveSelf = true;

        // Base behaviour
        GUIPanel::_Show( params );
    }

    void _Hide() override
    {
        // Make screen active
        _ActiveSelf = false;

        // Base behaviour
        GUIPanel::_Hide();
    }

    void _Appear( dictionary@ params ) override
    {
        // Set screen cursor
        ChangeCursor( _Cursor );

        // Base behaviour
        GUIPanel::_Appear( params );
    }

    void _Disappear() override
    {
        // Store cursor
        _Cursor = GetCurrentCursor();

        // Base behaviour
        GUIPanel::_Disappear();
    }

    // Options
    void SetModal( bool enabled )
    {
        _IsModal = enabled;
    }

    void SetMultiinstance( bool enabled )
    {
        _IsMultiinstance = enabled;
    }

    void SetCloseOnMiss( bool enabled )
    {
        _IsCloseOnMiss = enabled;
    }

    void SetCursor( int cursor )
    {
        _Cursor = cursor;
    }
}

shared class GUIGrid : GUIPanel
{
    string@      get_CellPrototype() final { return _CellPrototype; }
    uint         get_GridSize() final      { return _GridSize; }
    int          get_Columns() final       { return _Columns; }
    int          get_PaddingX() final      { return _PaddingX; }
    int          get_PaddingY() final      { return _PaddingY; }
    GUIObject@[] get_Cells() final         { return _Cells; }

    string@ _CellPrototype;
    uint    _GridSize;
    int     _Columns;
    int     _PaddingX;
    int     _PaddingY;
    GUIObject@[] _Cells;

    void _Init() override
    {
        if( _GridSize > 0 )
            ResizeGrid( _GridSize );

        GUIPanel::_Init();
    }

    void ResizeGrid( uint size )
    {
        // Find cell prototype
        if( _CellPrototype is null )
            return;
        GUIObject@ cellPrototype = Find( _CellPrototype );
        if( cellPrototype is null )
            return;

        // Get cell index
        uint cellIndex = cellPrototype._Parent._Children.findByRef( cellPrototype );

        // Remove current instances
        for( uint i = 0; i < _Children.length();)
        {
            if( _Cells.findByRef( _Children[ i ] ) != -1 )
                _Children.removeAt( i );
            else
                i++;
        }
        _Cells.resize( 0 );

        // Create new intsances
        cellPrototype._ActiveSelf = true;
        GUIObject@[] cellInstances;
        int col = 0, row = 0;
        for( uint i = 0; i < size; i++ )
        {
            GUIObject@ cellInstance = cellPrototype._CloneExt( this );
            cellPrototype._Parent._Children.removeLast();
            cellPrototype._Parent._Children.insertAt( ++cellIndex, cellInstance );
            _Cells.insertLast( cellInstance );
            cellInstance._Move( col * ( cellInstance._Width + _PaddingX ), row * ( cellInstance._Height + _PaddingY ), false, true );
            cellInstances.insertLast( cellInstance );

            if( ++col >= _Columns )
            {
                col = 0;
                row++;
            }
        }
        cellPrototype._ActiveSelf = false;

        // Callbacks
        for( uint i = 0; i < cellInstances.length(); i++ )
        {
            OnResizeGrid( cellInstances[ i ], i );
            _ResizeGrid( cellInstances[ i ], cellInstances[ i ], i );
        }

        // Init instances
        for( uint i = 0; i < cellInstances.length(); i++ )
            cellInstances[ i ]._Init();
    }

    void _ResizeGrid( GUIObject@ obj, GUIObject@ cell, uint cellIndex )
    {
        obj.OnResizeGrid( cell, cellIndex );

        for( uint i = 0; i < obj._Children.length(); i++ )
            _ResizeGrid( obj._Children[ i ], cell, cellIndex );
    }

    void SetCellPrototype( string name )
    {
        @_CellPrototype = name;
        if( _CellPrototype !is null )
        {
            GUIObject@ cellPrototype = Find( _CellPrototype );
            if( cellPrototype !is null )
                cellPrototype._ActiveSelf = false;
        }
    }

    void SetGridSize( uint size )
    {
        _GridSize = size;
    }

    void SetColumns( int length )
    {
        _Columns = length;
    }

    void SetPadding( int x, int y )
    {
        _PaddingX = x;
        _PaddingY = y;
    }
}

shared class GUIMessageBox : GUIText
{
    string[] get_MessageTexts() final   { return _MessageTexts; }
    int[]    get_MessageTypes() final   { return _MessageTypes; }
    string[] get_MessageTimes() final   { return _MessageTimes; }
    int[]    get_Filters() final        { return _Filters; }
    bool     get_InvertMessages() final { return _InvertMessages; }

    string[] _MessageTexts;
    int[]    _MessageTypes;
    string[] _MessageTimes;
    int[]    _Filters;
    bool   _InvertMessages;
    int    _Scroll;
    int    _MaxScroll;
    int    _ScrollLines;
    Sprite _ScrollUp;
    Sprite _ScrollDown;

    void Init( GUIObject@ parent ) override
    {
        GUIText::Init( parent );

        _ScrollUp.Load( "SUPARROW.FRM", PT_ART_INTRFACE );
        _ScrollDown.Load( "SDNARROW.FRM", PT_ART_INTRFACE );
    }

    void _Show( dictionary@ params ) override
    {
        GUIText::_Show( params );

        _InvertMessages = __MsgboxInvert;
        _GenerateText();
    }

    void _Draw() override
    {
        if( !_InvertMessages )
            _TextFlags = FT_UPPER | FT_BOTTOM | FT_SKIPLINES_END( _ScrollLines );
        else
            _TextFlags = FT_SKIPLINES( _ScrollLines );

        GUIText::_Draw();

        if( _IsHovered )
        {
            Sprite@ spr = ( __MouseY < _AbsolutePosY + _Height / 2 ? _ScrollUp : _ScrollDown );
            spr.Draw( __MouseX - spr.Width / 2, __MouseY - spr.Height / 2 );
        }
    }

    void _Remove() override
    {
        __HideCursor = false;

        GUIText::_Remove();
    }

    void _Hover() override
    {
        GUIText::_Hover();

        __HideCursor = true;
    }

    void _Unhover() override
    {
        GUIText::_Unhover();

        __HideCursor = false;
    }

    void _SizeChanged() override
    {
        _GenerateText();

        GUIText::_SizeChanged();
    }

    void _MousePressed( int button ) override
    {
        if( button == MOUSE_BUTTON_LEFT || button == MOUSE_BUTTON_WHEEL_UP || button == MOUSE_BUTTON_WHEEL_DOWN )
        {
            if( button == MOUSE_BUTTON_WHEEL_UP || ( button == MOUSE_BUTTON_LEFT && __MouseY < _AbsolutePosY + _Height / 2 ) )
            {
                if( _InvertMessages && _Scroll > 0 )
                    _Scroll--;
                if( !_InvertMessages && _Scroll < _MaxScroll )
                    _Scroll++;
            }
            else if( button == MOUSE_BUTTON_WHEEL_DOWN || ( button == MOUSE_BUTTON_LEFT && __MouseY >= _AbsolutePosY + _Height / 2 ) )
            {
                if( _InvertMessages && _Scroll < _MaxScroll )
                    _Scroll++;
                if( !_InvertMessages && _Scroll > 0 )
                    _Scroll--;
            }
            _GenerateText();
        }

        GUIText::_MousePressed( button );
    }

    void AddMessage( string@ text, int type )
    {
        // Skip error messages
        if( type == FOMB_GAME && text == "error" )
            return;

        // Set text
        string messageText;
        if( type >= FOMB_GAME && type <= FOMB_VIEW )
        {
            uint[] sayColors = { COLOR_DGREEN, COLOR_TEXT, COLOR_DRED, COLOR_DDGREEN };
            messageText = "|" + sayColors[ type ] + " " + EncodeUTF8( TEXT_SYMBOL_DOT ) + " |" + COLOR_TEXT + " " + text;
        }
        else
        {
            messageText = text;
        }
        _MessageTexts.insertLast( messageText );

        // Set type
        int messageType = type;
        _MessageTypes.insertLast( messageType );

        // Set time
        uint16 year = 0;
        uint16 month = 0;
        uint16 day = 0;
        uint16 dayOfWeek = 0;
        uint16 hour = 0;
        uint16 minute = 0;
        uint16 second = 0;
        uint16 milliseconds;
        GetTime( year, month, day, dayOfWeek, hour, minute, second, milliseconds );
        string messageTime = ( hour <= 9 ? "0" : "" ) + hour + ":" + ( minute <= 9 ? "0" : "" ) + minute + ":" + ( second <= 9 ? "0" : "" ) + second + " ";
        _MessageTimes.insertLast( messageTime );

        // Generate mess box
        if( _Filters.find( type ) == -1 )
        {
            if( _Scroll > 0 && _IsHovered )
                _Scroll++;
            else
                _Scroll = 0;
        }
        _GenerateText();
    }

    void _GenerateText()
    {
        if( !Active )
            return;

        _Text = "";
        if( _MessageTexts.length() == 0 )
            return;

        int tw = 0, th = 0;
        int maxLines = 0;
        GetTextInfo( null, _Width, _Height, _TextFont, 0, tw, th, maxLines );
        if( maxLines <= 0 )
        {
            _MaxScroll = 0;
            _ScrollLines = 0;
            return;
        }

        _ScrollLines = -1;
        int lines = 0;
        for( int i = _MessageTexts.length() - 1; i >= 0; i-- )
        {
            string@ messageText = _MessageTexts[ i ];
            int     messageType = _MessageTypes[ i ];
            string@ messageTime = _MessageTimes[ i ];

            // Filters
            if( _Filters.find( messageType ) != -1 )
                continue;

            // Skip scrolled lines
            int curLines = lines;
            int skipLines = 0;
            GetTextInfo( messageText, _Width, 1000, _TextFont, 0, tw, th, skipLines );
            lines += skipLines;

            if( _ScrollLines < 0 )
            {
                if( lines <= _Scroll )
                    continue;
                _ScrollLines = _Scroll - curLines;
            }

            if( curLines - _Scroll < maxLines )
            {
                // Add to message box
                if( _InvertMessages )
                    _Text += messageText + "\n";
                else
                    _Text = messageText + "\n" + _Text;
            }
            else
            {
                break;
            }
        }
        _MaxScroll = lines - maxLines;
        if( _ScrollLines < 0 )
            _ScrollLines = 0;
    }

    void SetFilters( int[] filters )
    {
        _Filters = filters;
        _GenerateText();
    }

    void SetFilter( int messageType, bool enable )
    {
        int index = _Filters.find( messageType );
        if( enable && index == -1 )
            _Filters.insertLast( messageType );
        else if( !enable && index != -1 )
            _Filters.removeAt( index );
        else
            return;

        _GenerateText();
    }

    void SetInvertMessages( bool invert )
    {
        _InvertMessages = invert;
        _GenerateText();
    }
}

#define CONSOLE_DATA_PREFIX    "console_"
shared class GUIConsole : GUITextInput
{
    bool   get_IsConsoleActive() final    { return _IsConsoleActive; }
    string get_HistoryStorageName() final { return _HistoryStorageName; }
    string[] @ get_History() final        {
        return _History;
    }
    uint get_HistoryMaxLength() final { return _HistoryMaxLength; }

    bool    _IsConsoleActive;
    string@ _HistoryStorageName;
    string  _HistoryActualStorageName;
    string[] _History;
    uint    _HistoryMaxLength;
    uint    _HistoryCur;

    void Init( GUIObject@ parent ) override
    {
        GUITextInput::Init( parent );

        SetCarriage( true );
        @_HistoryStorageName = "";
    }

    void _GlobalInput( uint8 key, string@ text ) override
    {
        GUITextInput::_GlobalInput( key, text );

        if( _IsConsoleActive )
        {
            if( key == DIK_UP && _HistoryCur > 0 )
            {
                _HistoryCur--;
                _Text = _History[ _HistoryCur ];
                _CarriagePos = _Text.length();
            }
            else if( key == DIK_DOWN )
            {
                if( _HistoryCur + 1 < _History.length() )
                {
                    _HistoryCur++;
                    _Text = _History[ _HistoryCur ];
                    _CarriagePos = _Text.length();
                }
                else
                {
                    _HistoryCur = _History.length();
                    _Text = "";
                    _CarriagePos = 0;
                }

            }
            else
            {
                GUITextInput::Input( key, text );
            }
        }

        if( key == DIK_RETURN || key == DIK_NUMPADENTER )
        {
            if( !_IsConsoleActive )
            {
                // Activate console
                _IsConsoleActive = true;

                // Load history
                string actualStorageName = "";
                if( _HistoryStorageName !is null && __Name !is null && __Name != "" )
                    actualStorageName = CONSOLE_DATA_PREFIX + __Name + _HistoryStorageName;

                if( _HistoryActualStorageName != actualStorageName )
                {
                    _History.resize( 0 );
                    _HistoryActualStorageName = actualStorageName;
                    if( _HistoryActualStorageName != "" )
                    {
                        Serializator data;
                        if( data.Load( _HistoryActualStorageName ) )
                            data.Get( _History );
                    }
                }

                _HistoryCur = _History.length();
            }
            else if( _Text.length() == 0 )
            {
                // Deactivate console
                _IsConsoleActive = false;
            }
            else
            {
                // Modify history
                _History.insertLast( _Text );
                for( uint i = 0; i < _History.length() - 1;)
                {
                    if( _History[ i ] == _History.last() )
                        _History.removeAt( i );
                    else
                        i++;
                }

                // Trim history length
                uint historyMaxLength = ( _HistoryMaxLength != 0 ? _HistoryMaxLength : __ConsoleHistorySize );
                while( _History.length() > historyMaxLength )
                    _History.removeAt( 0 );
                _HistoryCur = _History.length();

                // Save history
                if( _HistoryActualStorageName != "" )
                {
                    Serializator data;
                    data.Set( _History );
                    data.Save( _HistoryActualStorageName );
                }

                // Send
                bool[] @ keyPressed = Screen._InputKeyPressed;
                if( keyPressed[ DIK_LCONTROL ] || keyPressed[ DIK_RCONTROL ] )
                    CustomCall( "ConsoleMessage\n/s" + _Text, "\n" );
                else if( keyPressed[ DIK_LMENU ] || keyPressed[ DIK_RMENU ] )
                    CustomCall( "ConsoleMessage\n/w" + _Text, "\n" );
                else if( keyPressed[ DIK_LSHIFT ] || keyPressed[ DIK_RSHIFT ] )
                    CustomCall( "ConsoleMessage\n/r" + _Text, "\n" );
                else
                    CustomCall( "ConsoleMessage\n" + _Text, "\n" );

                // Clear text
                _Text = "";
                _CarriagePos = 0;
            }
        }
    }

    void Input( uint8 key, string@ text ) override
    {
        GUIText::Input( key, text );
    }

    void _Draw() override
    {
        if( _IsConsoleActive )
        {
            string@ text = Text;

            if( _CarriagePos < 0 )
                _CarriagePos = 0;
            if( _CarriagePos > int( text.length() ) )
                _CarriagePos = text.length();

            @text = text.substring( 0, _CarriagePos ) + ( GetTick() % 800 < 400 ? "!" : "." ) + text.substring( _CarriagePos );
            DrawText( text, _AbsolutePosX, _AbsolutePosY, _Width, _Height, _TextColor, _TextFont, _TextFlags );
        }

        GUIObject::_Draw();
    }

    void SetHistoryStorage( string storageName )
    {
        // Set storage name
        _HistoryStorageName = storageName;
    }

    void SetHistoryMaxLength( uint length )
    {
        _HistoryMaxLength = length;
    }
}

shared class GUIItemView : GUIGrid
{
    uint _CritterId;
    ItemCl@[] _Items;

    // Todo:
    // int _VerScroll;
    // int _HorScroll;
    // bool _CanDrag;
    // bool _ResortOnDrag;

    // Callbacks
    bool OnCheckItem( ItemCl@ item ) { return false; }

    void _Draw()
    {
        // Callbacks
        for( uint i = 0; i < _Cells.length(); i++ )
        {
            ItemCl@ item = ( i < _Items.length() ? _Items[ i ] : null );
            OnDrawItem( item, _Cells[ i ], i );
            _DrawItem( _Cells[ i ], item, _Cells[ i ], i );
        }

        GUIGrid::_Draw();
    }

    void _DrawItem( GUIObject@ obj, ItemCl@ item, GUIObject@ cell, uint cellIndex )
    {
        obj.OnDrawItem( item, cell, cellIndex );

        for( uint i = 0; i < obj._Children.length(); i++ )
            _DrawItem( obj._Children[ i ], item, cell, cellIndex );
    }

    void _Resort()
    {
        _Items.resize( 0 );

        CritterCl@ cr = ( _CritterId == 0 ? GetChosen() : GetCritter( _CritterId ) );
        if( cr !is null )
        {
            ItemCl@[] items;
            cr.GetItems( -1, items );
            for( uint i = 0; i < items.length(); i++ )
                if( OnCheckItem( items[ i ] ) )
                    _Items.insertLast( items[ i ] );
        }
    }

    void SetCritter( uint crId )
    {
        _CritterId = crId;
        _Resort();
    }
}

#endif // __CLIENT_GUI__
